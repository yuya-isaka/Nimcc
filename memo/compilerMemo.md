# コンパイラメモ

- コンパイラは仕組みがわかっていても，不思議な感じのするプログラム
- 再帰下降構文解析
- トークナイズ → パース → コードジェネレート
    > - トークナイザが入力を読み取ってトークン列を作成
    > - パーザがトークン列から構文木を構築
    > - ジェネレータが構文木を辿ってアセンブリを出力
- 文字列をトークン列に分割 → トークナイズ
- コンパイラ実装の都合上，トークン列の終端を表す特殊な型を一つ定義しておくとプログラムが簡潔になる
- C言語では，トークンはポインタで繋いだ連結リストとして設計
- パーサが読み込むトークン列はグローバル変数tokenで表現する
    > パーサは連結リストになっているtokenを辿って入力を進めていく

    > パーサのコードが読みやすくなる
- tokenを直接触るコードはconsumeやexpectといった関数に分けて，それ以外の関数ではtokenを触らないようにした
- tokenize関数は連結リストを構築する．
    > 連結リストを構築する際は，ダミーのhead要素を作ってそこに新しい要素を繋げていって，最後にhead->nextを返すようにするとコードが簡単になる．

    > head要素に割り当てられたメモリはほとんど無駄になるが，ローカル変数をアロケートするコストはほぼゼロだから気にする必要はない

- 10以上の数を表現する際に，C言語ではstrtolという便利関数があったが，Nimにはなかったので，checkNumという関数を自作した．(まあ難しいことじゃない．もっとエレガントに書けるはずなんだが．．)

- 現状はトークン列をポインタ（先頭のアドレス）で持つのではなく，charの配列で持って，インデックスを進めてアクセスしてるから，ちょっとややこしい

- 入力文字列の扱いもC言語と違って，ちょっと違う実装をしている

- パーサ
    > 入力はフラットなトークンの列，出力は入れ子構造を表す木（構文木）

    > 抽象構文木（AST）

- 構文解析におけるゴールは抽象構文木を構築すること（トークン列をASTに）
    - この構文木をアセンブリに変換

- プログラミング言語の構文の大部分 → 「生成規則」で定義される
    - 演算子の優先順位

- 「生成規則」の記述方法 → 「BNF」「EBNF」

- 再帰下降構文解析テクニック
    - 入力文字列を，「ある生成規則」に合った抽象構文木に変換するためのテクニック
    - 「生成規則」を関数にマッピング

- LL(1)パーサ
    - トークンを１つだけ先読みする再帰下降パーサ

- スタックマシン
    - スタックをデータ保存領域として使っているコンピュータ
    - 複数の途中結果を持つどのような式でも計算できる

- 抽象構文木をスタックマシンのコードに変換する
    - 四則演算ができるコンパイラができる！
    > 再帰的に木を下りながらアセンブリを種直していく

- 実際のx86-64はスタックマシンではなくレジスタマシン
    - レジスタマシンでスタックマシンをエミュレート
    - スタックマシンの１命令を複数の命令を使って実装すればいい
    > スタックポインタ

- "=="などの2文字あるやつを先にトークナイズしないと，"<="を"<"として認識してまうから気をつける

- 連結リストcur.next = tok  return tok とかは左から右に生やしている．この形式の場合は，先頭に空のheadを用意していてhead.nextに繋げていく方式にしている．そして最後にhead.nextを返せば，連結リストの先頭を取得できる．この形式だとheadが無駄になるが，まあたいして気にならない．

- 連結リストarg.next = locals  return arg とかは右から左に生やしている．この形式は先頭のheadがいらない．なぜこの形にしているかというと，先頭を取得する必要性がないから．(順番とかどうでもいい）下から上に生やしていって，最後に参照しているlocalsに残っている末尾を先頭として扱う方が効率がいい．

- アセンブリでLから始まるラベルは外部ファイルから参照できないから，コンフリクトしない

- 左辺値...Cにおいて代入式の左辺に来ることができるのは，基本的にメモリのアドレスを指定する式だけ

- 全てをノードとして扱う方が効率がいい（NdExpr)

- storeのpush rdiとgenのNdExprStmtのadd rsp, 8の両方を消してもテスト通った．

- !今回のnimccでの{}の中身はベクタ（配列）として持っている．他の連続したnodeとかtokenとかlocalsとかは，連結リストとして持っているが，これは配列として扱ってみた．後々，全てを配列に置き換えよう！(そのほうが後ろにもどたりできて便利だと思われ．．)


## びっくりしたこと

- 関数の引数の扱い方
- sub(7, 3, 3) int sub(a, b, c) { return a - b - c; } のような関数がある場合，　まず関数の引数に渡された7,3,3が専用のレジスタに渡される．　その後に　定義された部分で引数のある場所（スタック領域）にそのレジスタの値を代入している．　
- 今までは定義されてるところに，後で値が入るもんだと思ってたら，実際は値が先にレジスタに入ってて，定義部分の変数に値が代入されるのは後だった．びっくりすぎる．
- (関数に関数を渡すときめちゃくちゃめんどくさくない？？？？？？？？？) やってみたら面白いかも
- アセンブリではmain:がエントリーポイント．（今のところ前方宣言は実装していない）

- 配列の実装方法
- a[3] -> *(a+3) としてコンパイラは解釈し，それをアセンブリに変換するとき，型を配列の時はアドレスを返すと言うだけにしておくことで，NdDerefからNdAddで綺麗にアドレスを計算して値を参照するという仕組みができていて感動した．
