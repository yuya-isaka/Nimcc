# コンパイラメモ

- コンパイラは仕組みがわかっていても，不思議な感じのするプログラム
- 再帰下降構文解析
- トークナイズ → パース → コードジェネレート
    > - トークナイザが入力を読み取ってトークン列を作成
    > - パーザがトークン列から構文木を構築
    > - ジェネレータが構文木を辿ってアセンブリを出力
- 文字列をトークン列に分割 → トークナイズ
- コンパイラ実装の都合上，トークン列の終端を表す特殊な型を一つ定義しておくとプログラムが簡潔になる
- C言語では，トークンはポインタで繋いだ連結リストとして設計
- パーサが読み込むトークン列はグローバル変数tokenで表現する
    > パーサは連結リストになっているtokenを辿って入力を進めていく

    > パーサのコードが読みやすくなる
- tokenを直接触るコードはconsumeやexpectといった関数に分けて，それ以外の関数ではtokenを触らないようにした
- tokenize関数は連結リストを構築する．
    > 連結リストを構築する際は，ダミーのhead要素を作ってそこに新しい要素を繋げていって，最後にhead->nextを返すようにするとコードが簡単になる．

    > head要素に割り当てられたメモリはほとんど無駄になるが，ローカル変数をアロケートするコストはほぼゼロだから気にする必要はない

- 10以上の数を表現する際に，C言語ではstrtolという便利関数があったが，Nimにはなかったので，checkNumという関数を自作した．(まあ難しいことじゃない．もっとエレガントに書けるはずなんだが．．)

- 現状はトークン列をポインタ（先頭のアドレス）で持つのではなく，charの配列で持って，インデックスを進めてアクセスしてるから，ちょっとややこしい

- 入力文字列の扱いもC言語と違って，ちょっと違う実装をしている

